
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MathBox - Example: Axis labeling.</title>

  <!--
    This example shows labelling of axes.
  -->

  <script type="text/javascript" charset="utf-8" src="mathbox/domready.js"></script>
  <script type="text/javascript" charset="utf-8" src="mathbox/mathbox.js"></script>

  <script type="text/javascript" charset="utf-8">
    DomReady.ready(function () {
      if (location.href.match(/^file:/)) {
        document.getElementById('info').style.opacity = 1;
        document.getElementById('info').innerHTML = "Sorry. This example does not work when accessed using file://. Please use an http:// host and try again.";
      }
    });
  </script>

  <script type="text/javascript" charset="utf-8">

  var brown = 0x924000,
      orangered = 0xc03000,
      red = 0xc02050,
      green = 0x50c020,
      inside = 0xf9ffe8,
      darkgreen = 0x509000,
      darkergreen = 0x284800,
      blue = 0x3080ff,
      lightblue = 0x8bb8ff,
      darkblue = 0x17408f,
      surfacered = 0xdf5000,
      purple = 0xd040b0,
      darkpurple = 0x95227c,
      royal = 0x5528A0,
      gold = 0xefc040,
      slate = 0x5070A0,
      darkslate = 0x45628d,
      cyan = 0x30A0B0,
      darkcyan = 0x24876f,
      lightgray = 0xe0e0e0;
      gray = 0xc0c0c0;
      darkgray = 0xa0a0a0,
      orange = 0xFF9703,
      darkorange = 0xc46a02,
      white = 0xffffff,
      black = 0x404040;

  var armLength = 172;
  var theta0 = -π/4;
  var theta1 = π/3;

  function bicepPosAt(bAngle, fAngle) {
    var sin = Math.sin;
    var cos = Math.cos;
    return [armLength * cos(bAngle), 0, armLength * sin(bAngle)];
  }
  function forearmPosAt(bAngle, fAngle) {
    var sin = Math.sin;
    var cos = Math.cos;
    var b = bicepPosAt(bAngle, fAngle)
    return [b[0] + armLength * cos(fAngle), 0, b[2] + armLength * sin(fAngle)];
  }
  window.mathboxScript = [
    // Nothing
    [
      ['add', 'grid', {
        axis: [0, 2],
        color: gray,
        lineWidth: 1,
        tickUnit: [8, 8], 
      }],
    ],

    //Draw vectors
    [
      ['add', 'vector', {
        id: 'bicep',
        color: red,
        lineWidth: 50,
        size: 10,
        expression: function(i, end) {
          if(!end)
            return [0, 0, 0];
          else
            return bicepPosAt(theta0, theta1);
        }
      }],
      ['add', 'vector', {
        id: 'forearm',
        color: red,
        lineWidth: 50,
        size: 10,
        expression: function(i, end) {
          if(!end)
            return bicepPosAt(theta0, theta1);
          else
            return forearmPosAt(theta0, theta1);
        }
      }]
    ],

    //Draw angles
    [
      //zero line
      ['add', 'vector', {
        id: 'parallel',
        color: darkgray,
        lineWidth: 50,
        size: 10,
        expression: function(i, end) {
          var at = bicepPosAt(theta0, theta1);
          if(end)
            return [at[0] + 50, 0, at[2]];
          else
            return at;
        }
      }],

      //arcs
      ['add', 'surface', {
        id: 'bicepAngle',
        color: green,
        opacity: 0.5,
        lineWidth: 50,
        shaded: false,
        size: 10,
        domain: [[20, 40], [0, theta0]],
        n: [2, 256],
        expression: function(r, theta) {
          return [r*Math.cos(theta), 0, r*Math.sin(theta)]
        }
      }, {'delay': 300}],
      ['add', 'surface', {
        id: 'forearmAngle',
        color: blue,
        opacity: 0.5,
        lineWidth: 50,
        shaded: false,
        size: 10,
        domain: [[20, 40], [0, theta1]],
        n: [2, 256],
        expression: function(r, theta) {
          var at = bicepPosAt(theta0, theta1);
          return [at[0] + r*Math.cos(theta), 0, at[2]+ r*Math.sin(theta)]
        }
      }, {'delay': 300}]
    ],

    //Draw surface
    [
      ['add', 'surface', {
        shaded: false,
        line: true,
        mesh: false,
        domain: [[-π/2, π/2], [-π/2, π]],
        n: [33, 33],
        expression: function(a, b) {
          if(a > b - 0.05*π) a = b - 0.05*π;
          if(a < b - 0.95*π) a = b - 0.95*π;
          var p = forearmPosAt(a, b);
          if(p[0] < 0) p[0] = 0;
          if(p[2] < 0) p[2] = 0;
          return p;
        },
      }]
    ]
  ]
  /**
   * Bootstrap
   */
  DomReady.ready(function() {
    ThreeBox.preload([
      'mathbox/snippets.glsl.html',
    ], function (){


      // MathBox boilerplate
      var mathbox = window.mathbox = mathBox({
        cameraControls: true,
        cursor:         true,
        controlClass:   ThreeBox.OrbitControls,
        elementResize:  true,
        fullscreen:     true,
        screenshot:     true,
        stats:          false,
        scale:          1,
      });

      

      // Receive navigation commands from parent frame
      window.addEventListener("message", function (e) {
        var data, method, args;

        if (data = e.data.mathBoxDirector) {
          method = data.method;
          args = data.args || [];
          _.each(window.director, function (director) {
            if (director[method]) {
              director[method].apply(director, args);
            }
          });
        }

        if (data = e.data.mathBox) {
          method = data.method;
          args = data.args || [];
          _.each(window.mathbox, function (mathbox) {
            if (method == 'speed') {
              target = args[0];
            }
            else if (mathbox[method]) {
              mathbox[method].apply(mathbox, args);
            }
          })
        }

      }, false);

      // Set up director
      var script = window.mathboxScript;
      var director = window.director = new MathBox.Director(mathbox, script);

      // Arrow controls
      // Controls for stand-alone
      window.addEventListener('keydown', function (e) {
        if (e.keyCode == 38 || e.keyCode == 37) director.back();
        else if (e.keyCode == 40 || e.keyCode == 39) director.forward();
        else {
          return;
        }

        document.getElementById('info').style.opacity = '0';
      });

      // Viewport camera/setup
      mathbox
        // Cartesian viewport
        .viewport({
          type: 'cartesian',
          range: [[0, 200], [0, 50], [0, 300]],
          scale: [200, 50, -300]
        })
        .camera({
          orbit: 800,
          phi: 0,
          theta: 0.3,
        })
        .transition(600)        

    });
  });
  </script>

  <style type="text/css" media="screen">
    html, body { height: 100%; }
    body { margin: 0; padding: 0 }
    canvas { display: block }

    #info {
      position: absolute;
      left: 50%;
      bottom: 50px;
      z-index: 20;

      width: 300px;
      margin-left: -150px;

      padding: 25px;
      background: rgba(0, 0, 0, .5);
      color: #fff;

      font-family: "Lucida Grande", sans-serif;
      font-size: 16px;
      text-align: center;

      border-radius: 3px;
      text-shadow: 0px 1px 0px rgba(0, 0, 0, .4);

      opacity: 0;
    }

    #info kbd {
      background: #aaa;

      box-shadow: 0px 1px 1px rgba(0, 0, 0, .3);
      border-radius: 3px;
      padding: 3px;
      margin: 3px;

      font-family: inherit;
    }
  </style>

</head>
<body>
  <div id="info"></div>
</body>
</html>
